"""
ElectionModel - Main simulation model using mesa-frames
Implements India-scale electoral simulation with constituency-based structure

Based on mesa-frames patterns from the official tutorials.
"""

from __future__ import annotations

import numpy as np
import polars as pl
from mesa_frames import AgentSet, Model, DataCollector

from electoral_sim.systems.allocation import dhondt_allocation, sainte_lague_allocation
from electoral_sim.metrics.indices import gallagher_index, effective_number_of_parties
from electoral_sim.numba_accel import (
    vote_mnl_fast, 
    fptp_count_fast,
    compute_utilities_numba,
    NUMBA_AVAILABLE,
)


# =============================================================================
# VOTER AGENTS
# =============================================================================

class VoterAgents(AgentSet):
    """
    Voter agents stored as Polars DataFrame for vectorized operations.
    
    Columns:
        - unique_id: Agent identifier (auto-generated by mesa-frames)
        - constituency: Constituency index (0 to n_constituencies-1)
        - ideology_x: Economic left-right (-1 to 1)
        - ideology_y: Social liberal-conservative (-1 to 1)
        - party_id: Current party identification
        - turnout_prob: Base probability of voting (0-1)
    """
    
    def __init__(self, model: Model, agent_frame: pl.DataFrame):
        """Initialize VoterAgents with a pre-built DataFrame."""
        super().__init__(model)
        self.add(agent_frame.clone())
        # Cache for numpy arrays (invalidated on changes)
        self._ideology_x_cache: np.ndarray | None = None
        self._ideology_y_cache: np.ndarray | None = None
        self._turnout_cache: np.ndarray | None = None
        self._constituency_cache: np.ndarray | None = None
    
    def get_ideology_x(self) -> np.ndarray:
        """Get ideology_x as numpy array. Cached."""
        if self._ideology_x_cache is None:
            self._ideology_x_cache = self.df["ideology_x"].to_numpy()
        return self._ideology_x_cache
    
    def get_ideology_y(self) -> np.ndarray:
        """Get ideology_y as numpy array. Cached."""
        if self._ideology_y_cache is None:
            self._ideology_y_cache = self.df["ideology_y"].to_numpy()
        return self._ideology_y_cache
    
    def get_turnout_prob(self) -> np.ndarray:
        """Get turnout_prob as numpy array. Cached."""
        if self._turnout_cache is None:
            self._turnout_cache = self.df["turnout_prob"].to_numpy()
        return self._turnout_cache
    
    def get_constituencies(self) -> np.ndarray:
        """Get constituency assignments as numpy array. Cached."""
        if self._constituency_cache is None:
            self._constituency_cache = self.df["constituency"].to_numpy()
        return self._constituency_cache
    
    def get_positions(self) -> np.ndarray:
        """Return voter positions as (n_voters, 2) array."""
        return np.column_stack([self.get_ideology_x(), self.get_ideology_y()])
    
    def invalidate_cache(self) -> None:
        """Clear cached values (call after modifying voter data)."""
        self._ideology_x_cache = None
        self._ideology_y_cache = None
        self._turnout_cache = None
        self._constituency_cache = None
    
    def step(self) -> None:
        """Called each simulation step for opinion dynamics."""
        # Placeholder for opinion dynamics
        pass


class PartyAgents(AgentSet):
    """
    Party agents stored as Polars DataFrame.
    
    Columns:
        - unique_id: Party identifier
        - name: Party name
        - position_x: Economic left-right (-1 to 1)
        - position_y: Social liberal-conservative (-1 to 1)  
        - valence: Non-policy appeal (0-100)
        - seats: Current seat count
        - vote_share: Last election vote share
    """
    
    def __init__(self, model: Model, agent_frame: pl.DataFrame):
        """Initialize PartyAgents with a pre-built DataFrame."""
        super().__init__(model)
        self.add(agent_frame.clone())
        # Cache for positions (invalidated on changes)
        self._positions_cache: np.ndarray | None = None
        self._valence_cache: np.ndarray | None = None
    
    def get_positions(self) -> np.ndarray:
        """Return party positions as (n_parties, 2) array. Cached."""
        if self._positions_cache is None:
            self._positions_cache = np.column_stack([
                self.df["position_x"].to_numpy(),
                self.df["position_y"].to_numpy()
            ])
        return self._positions_cache
    
    def get_valence(self) -> np.ndarray:
        """Return party valence array. Cached."""
        if self._valence_cache is None:
            self._valence_cache = self.df["valence"].to_numpy()
        return self._valence_cache
    
    def invalidate_cache(self) -> None:
        """Clear cached values (call after modifying positions/valence)."""
        self._positions_cache = None
        self._valence_cache = None
    
    def step(self) -> None:
        """Called each step for party adaptation."""
        pass


# =============================================================================
# ELECTION MODEL
# =============================================================================

class ElectionModel(Model):
    """
    Main election simulation model using mesa-frames.
    
    Supports:
        - Multiple constituencies (default: 543 for Lok Sabha)
        - Configurable electoral systems (FPTP, PR with D'Hondt/Sainte-Laguë)
        - Multinomial logit voting model
        - Opinion dynamics (placeholder)
    
    Examples:
        # Simple usage
        model = ElectionModel(n_voters=100_000)
        results = model.run_election()
        
        # Using Config
        from electoral_sim import Config
        config = Config(n_voters=100_000, electoral_system="PR")
        model = ElectionModel.from_config(config)
        
        # Using presets
        model = ElectionModel.from_preset("india")
        
        # Chainable API
        results = (
            ElectionModel(n_voters=100_000)
            .with_system("PR")
            .run_election()
        )
    
    Parameters
    ----------
    n_voters : int
        Total number of voter agents
    n_constituencies : int
        Number of electoral constituencies
    parties : list[dict]
        Party configurations with name, position_x, position_y, valence
    voter_frame : pl.DataFrame | None
        Optional pre-built voter DataFrame (bypasses automatic generation)
    party_frame : pl.DataFrame | None
        Optional pre-built party DataFrame
    electoral_system : str
        'FPTP' or 'PR'
    allocation_method : str
        'dhondt' or 'sainte_lague' (for PR)
    threshold : float
        Electoral threshold for PR (0-1)
    temperature : float
        MNL temperature parameter (lower = more deterministic)
    seed : int | None
        Random seed for reproducibility
    """
    
    def __init__(
        self,
        n_voters: int = 100_000,
        n_constituencies: int = 10,
        parties: list[dict] | None = None,
        voter_frame: pl.DataFrame | None = None,
        party_frame: pl.DataFrame | None = None,
        electoral_system: str = "FPTP",
        allocation_method: str = "dhondt",
        threshold: float = 0.0,
        temperature: float = 0.5,
        seed: int | None = None,
        behavior_engine: "BehaviorEngine" | None = None,
        opinion_dynamics: "OpinionDynamics" | None = None,
    ):
        super().__init__(seed)
        
        # Store configuration
        self.n_constituencies = n_constituencies
        self.electoral_system = electoral_system
        self.allocation_method = allocation_method
        self.threshold = threshold
        self.temperature = temperature
        
        # Behavior & Dynamics
        from electoral_sim.voter_behavior import BehaviorEngine, ProximityModel, ValenceModel
        if behavior_engine is None:
            # Default behavior: Proximity + Valence
            self.behavior_engine = BehaviorEngine()
            self.behavior_engine.add_model(ProximityModel())
            self.behavior_engine.add_model(ValenceModel())
        else:
            self.behavior_engine = behavior_engine
            
        self.opinion_dynamics = opinion_dynamics

        # Default parties if not provided and no party_frame
        if parties is None and party_frame is None:
            parties = [
                {"name": "Party A", "position_x": -0.3, "position_y": 0.1, "valence": 50},
                {"name": "Party B", "position_x": 0.3, "position_y": -0.1, "valence": 50},
                {"name": "Party C", "position_x": 0.0, "position_y": 0.3, "valence": 45},
            ]
        
        # Create or use DataFrames
        if voter_frame is not None:
            self.voters = VoterAgents(self, voter_frame)
            if "constituency" in voter_frame.columns:
                self.n_constituencies = int(voter_frame["constituency"].max() + 1)
        else:
            self.voters = VoterAgents(self, self._generate_voter_frame(n_voters))
            
        if party_frame is not None:
            self.parties = PartyAgents(self, party_frame)
            self.n_parties = len(party_frame)
        else:
            self.parties = PartyAgents(self, self._generate_party_frame(parties))
            self.n_parties = len(self.parties)
        
        # Register agent sets with model
        self.sets += self.voters
        self.sets += self.parties
        
        # Results storage
        self.election_results: list[dict] = []
        
        # Set up data collector
        self.datacollector = DataCollector(
            model=self,
            model_reporters={
                "n_voters": lambda m: len(m.voters),
                "mean_turnout": lambda m: float(m.voters.df["turnout_prob"].mean()),
            },
        )
        self.datacollector.collect()
    
    # =========================================================================
    # CLASS METHODS (Factory methods)
    # =========================================================================
    
    @classmethod
    def from_config(cls, config: "Config") -> "ElectionModel":
        """
        Create model from a Config object.
        
        Args:
            config: Config instance with all parameters
            
        Returns:
            ElectionModel instance
        
        Example:
            config = Config(n_voters=100_000, electoral_system="PR")
            model = ElectionModel.from_config(config)
        """
        from electoral_sim.config import Config
        
        return cls(
            n_voters=config.n_voters,
            n_constituencies=config.n_constituencies,
            parties=config.get_party_dicts(),
            electoral_system=config.electoral_system,
            allocation_method=config.allocation_method,
            threshold=config.threshold,
            temperature=config.temperature,
            seed=config.seed,
        )
    
    @classmethod
    def from_preset(cls, preset: str, **kwargs) -> "ElectionModel":
        """
        Create model from a country preset.
        
        Args:
            preset: One of 'india', 'usa', 'uk', 'germany'
            **kwargs: Override any preset parameters
            
        Returns:
            ElectionModel instance
        
        Example:
            model = ElectionModel.from_preset("india", n_voters=500_000)
        """
        from electoral_sim.config import PRESETS
        
        if preset.lower() not in PRESETS:
            available = list(PRESETS.keys())
            raise ValueError(f"Unknown preset: {preset}. Available: {available}")
        
        config = PRESETS[preset.lower()](**kwargs)
        return cls.from_config(config)
    
    # =========================================================================
    # CHAINABLE API
    # =========================================================================
    
    def with_system(self, system: str) -> "ElectionModel":
        """
        Set electoral system. Chainable.
        
        Args:
            system: 'FPTP' or 'PR'
            
        Returns:
            self for chaining
        """
        self.electoral_system = system
        return self
    
    def with_allocation(self, method: str) -> "ElectionModel":
        """
        Set PR allocation method. Chainable.
        
        Args:
            method: 'dhondt', 'sainte_lague', 'hare', or 'droop'
            
        Returns:
            self for chaining
        """
        self.allocation_method = method
        return self
    
    def with_threshold(self, threshold: float) -> "ElectionModel":
        """
        Set electoral threshold. Chainable.
        
        Args:
            threshold: 0-1 (e.g., 0.05 for 5%)
            
        Returns:
            self for chaining
        """
        self.threshold = threshold
        return self
    
    def with_temperature(self, temperature: float) -> "ElectionModel":
        """
        Set MNL temperature. Chainable.
        
        Args:
            temperature: Lower = more deterministic voting
            
        Returns:
            self for chaining
        """
        self.temperature = temperature
        return self
    
    def _generate_voter_frame(self, n_voters: int) -> pl.DataFrame:
        """
        Generate initial voter DataFrame with full demographics.
        
        Includes:
            - Demographics: age, gender, education, income, religion
            - Party ID: 7-point scale (-3 to +3)
            - Ideology: 2D position
            - Turnout probability
        """
        rng = self.random
        
        # Demographics
        age = rng.integers(18, 90, size=n_voters)  # Voting age population
        gender = rng.choice([0, 1], size=n_voters)  # 0=Male, 1=Female
        
        # Education: 0=None, 1=Primary, 2=Secondary, 3=Graduate, 4=Post-grad
        education = rng.choice([0, 1, 2, 3, 4], size=n_voters, p=[0.15, 0.25, 0.30, 0.20, 0.10])
        
        # Income percentile (0-100)
        income = np.clip(rng.lognormal(3.5, 0.8, n_voters), 0, 100)
        
        # Religion: simplified categories (0-5)
        religion = rng.choice([0, 1, 2, 3, 4, 5], size=n_voters, p=[0.65, 0.14, 0.10, 0.05, 0.03, 0.03])
        
        # 7-point Party ID scale: -3=Strong Left, 0=Independent, +3=Strong Right
        # Normally distributed, clipped to range
        party_id_7pt = np.clip(np.round(rng.normal(0, 1.2, n_voters)), -3, 3).astype(int)
        
        # Ideology influenced by demographics
        # Age: older slightly more conservative
        # Education: higher ed slightly more liberal on social issues
        # Income: higher income slightly more conservative on economic
        base_ideology_x = rng.normal(0, 0.3, n_voters)
        base_ideology_y = rng.normal(0, 0.3, n_voters)
        
        ideology_x = np.clip(
            base_ideology_x + 0.005 * (income - 50) + 0.003 * (age - 50),
            -1, 1
        )
        ideology_y = np.clip(
            base_ideology_y - 0.02 * (education - 2) + 0.005 * (age - 50),
            -1, 1
        )
        
        # Turnout influenced by education and age
        base_turnout = rng.beta(5, 2, n_voters)
        turnout_prob = np.clip(
            base_turnout + 0.02 * education + 0.002 * np.minimum(age - 18, 50),
            0.1, 0.95
        )
        
        return pl.DataFrame({
            # Demographics
            "constituency": rng.integers(0, self.n_constituencies, size=n_voters),
            "age": age,
            "gender": gender,
            "education": education,
            "income": income.astype(np.float64),
            "religion": religion,
            # Political identity
            "party_id_7pt": party_id_7pt,  # -3 to +3 scale
            "ideology_x": ideology_x,
            "ideology_y": ideology_y,
            # Behavior
            "turnout_prob": turnout_prob,
        })
    
    def _generate_party_frame(self, parties: list[dict]) -> pl.DataFrame:
        """Generate party DataFrame from configuration."""
        n = len(parties)
        return pl.DataFrame({
            "name": [p.get("name", f"Party {i}") for i, p in enumerate(parties)],
            "position_x": [float(p.get("position_x", 0.0)) for p in parties],
            "position_y": [float(p.get("position_y", 0.0)) for p in parties],
            "valence": [float(p.get("valence", 50.0)) for p in parties],
            "incumbent": [bool(p.get("incumbent", False)) for p in parties],
            "seats": np.zeros(n, dtype=np.int64),
            "vote_share": np.zeros(n, dtype=np.float64),
        })
    
    def _compute_utilities(self, **kwargs) -> np.ndarray:
        """
        Compute utility matrix using the configured behavior engine.
        """
        voter_data = {
            'n_voters': len(self.voters),
            'positions': self.voters.get_positions(),  # Need to add this to VoterAgents
            'ideology_x': self.voters.get_ideology_x(),
            'ideology_y': self.voters.get_ideology_y(),
            'df': self.voters.df
        }
        
        party_data = {
            'n_parties': len(self.parties),
            'positions': self.parties.get_positions(),
            'valence': self.parties.get_valence(),
            'incumbents': self.parties.df["incumbent"].to_numpy() if "incumbent" in self.parties.df else np.zeros(len(self.parties), dtype=bool),
            'df': self.parties.df
        }
        
        return self.behavior_engine.compute_all(voter_data, party_data, **kwargs)
    
    def _vote_mnl(self, utilities: np.ndarray) -> np.ndarray:
        """
        Multinomial logit voting: P(j) = exp(U_j/τ) / Σexp(U_k/τ)
        
        Uses Numba acceleration when available (~10x faster).
        
        Returns array of vote choices (party indices).
        """
        return vote_mnl_fast(utilities, self.temperature, self.random)
    
    def _decide_turnout(self) -> np.ndarray:
        """Determine which voters turn out based on turnout probability."""
        turnout_probs = self.voters.get_turnout_prob()
        random_vals = self.random.random(len(turnout_probs))
        return random_vals < turnout_probs
    
    def run_election(self, **kwargs) -> dict:
        """
        Run a single election and return results.
        
        Args:
            **kwargs: Extra parameters passed to the behavior engine (e.g. growth=0.03)
            
        Returns:
            Dictionary with vote counts, seats, turnout, and metrics
        """
        # Compute utilities and cast votes
        utilities = self._compute_utilities(**kwargs)
        votes = self._vote_mnl(utilities)
        
        # Determine turnout
        will_vote = self._decide_turnout()
        
        # Filter to voters who turned out (use cached constituencies)
        constituencies = self.voters.get_constituencies()
        voted_constituencies = constituencies[will_vote]
        voted_choices = votes[will_vote]
        
        # Count votes
        if self.electoral_system == "FPTP":
            results = self._count_fptp(voted_constituencies, voted_choices)
        else:
            results = self._count_pr(voted_choices)
        
        # Calculate metrics
        vote_shares = results["vote_counts"] / results["vote_counts"].sum()
        seat_shares = results["seats"] / results["seats"].sum() if results["seats"].sum() > 0 else vote_shares
        
        results["gallagher"] = gallagher_index(vote_shares, seat_shares)
        results["enp_votes"] = effective_number_of_parties(vote_shares)
        results["enp_seats"] = effective_number_of_parties(seat_shares)
        results["turnout"] = will_vote.sum() / len(will_vote)
        
        # Update party DataFrame with results
        self.parties.df = self.parties.df.with_columns([
            pl.Series("seats", results["seats"]),
            pl.Series("vote_share", vote_shares),
        ])
        
        self.election_results.append(results)
        return results
    
    def _count_fptp(self, constituencies: np.ndarray, votes: np.ndarray) -> dict:
        """
        First Past The Post: winner takes all in each constituency.
        
        Uses Numba parallel acceleration when available.
        """
        seats, vote_counts = fptp_count_fast(
            constituencies, votes, self.n_constituencies, self.n_parties
        )
        
        return {
            "system": "FPTP",
            "seats": seats,
            "vote_counts": vote_counts,
            "n_constituencies": self.n_constituencies,
        }
    
    def _count_pr(self, votes: np.ndarray) -> dict:
        """Proportional Representation with seat allocation."""
        # Vectorized vote counting
        vote_counts = np.bincount(votes, minlength=self.n_parties).astype(np.int64)
        
        # Allocate seats using registry for all methods
        from electoral_sim.systems.allocation import allocate_seats
        seats = allocate_seats(vote_counts, self.n_constituencies, self.allocation_method, self.threshold)
        
        return {
            "system": "PR",
            "method": self.allocation_method,
            "seats": seats,
            "vote_counts": vote_counts,
            "n_constituencies": self.n_constituencies,
        }
    
    def step(self) -> None:
        """Run one simulation step (for opinion dynamics)."""
        if self.opinion_dynamics:
            # Update ideologies based on social network
            current_ideologies = self.voters.df["ideology_x"].to_numpy() # Example for 1D
            # Actually OpinionDynamics.step expects opinions as class labels usually, 
            # but we can use bounded_confidence for continuous ideologies.
            # Let's assume we use ideology_x for now as a proof of concept.
            new_ideologies_x = self.opinion_dynamics.step(
                self.voters.get_ideology_x(), 
                model="bounded_confidence"
            )
            new_ideologies_y = self.opinion_dynamics.step(
                self.voters.get_ideology_y(), 
                model="bounded_confidence"
            )
            # Update the frame
            self.voters.df = self.voters.df.with_columns([
                pl.Series("ideology_x", new_ideologies_x),
                pl.Series("ideology_y", new_ideologies_y),
            ])
            self.voters.invalidate_cache()
            
        self.sets.do("step")
        self.datacollector.collect()
    
    def run(self, n_steps: int = 100, election_interval: int = 10) -> None:
        """
        Run simulation for n_steps, holding elections at intervals.
        
        Args:
            n_steps: Total simulation steps
            election_interval: Steps between elections
        """
        for step in range(n_steps):
            self.step()
            
            if (step + 1) % election_interval == 0:
                self.run_election()
    
    def get_results(self) -> list[dict]:
        """Return all election results."""
        return self.election_results
    
    def run_elections_batch(self, n_elections: int = 10, reset_voters: bool = False, **kwargs) -> list[dict]:
        """
        Run multiple elections in batch for Monte Carlo analysis.
        
        More efficient than calling run_election() in a loop because it
        reuses cached data and avoids repeated overhead.
        
        Args:
            n_elections: Number of elections to run
            reset_voters: If True, regenerate voters between elections
            **kwargs: Extra parameters passed to the behavior engine
            
        Returns:
            List of election result dictionaries
        """
        batch_results = []
        
        for i in range(n_elections):
            if reset_voters and i > 0:
                # Regenerate voter positions/turnout (expensive)
                n_voters = len(self.voters)
                voter_frame = self._generate_voter_frame(n_voters)
                self.voters.df = voter_frame
            
            results = self.run_election(**kwargs)
            batch_results.append(results)
        
        return batch_results
    
    def get_aggregate_stats(self, results: list[dict] | None = None) -> dict:
        """
        Compute aggregate statistics across multiple elections.
        
        Args:
            results: List of election results (default: use stored results)
            
        Returns:
            Dictionary with mean/std of key metrics
        """
        if results is None:
            results = self.election_results
        
        if not results:
            return {}
        
        turnouts = np.array([r["turnout"] for r in results])
        gallaghers = np.array([r["gallagher"] for r in results])
        enp_votes = np.array([r["enp_votes"] for r in results])
        enp_seats = np.array([r["enp_seats"] for r in results])
        
        return {
            "n_elections": len(results),
            "turnout_mean": float(turnouts.mean()),
            "turnout_std": float(turnouts.std()),
            "gallagher_mean": float(gallaghers.mean()),
            "gallagher_std": float(gallaghers.std()),
            "enp_votes_mean": float(enp_votes.mean()),
            "enp_votes_std": float(enp_votes.std()),
            "enp_seats_mean": float(enp_seats.mean()),
            "enp_seats_std": float(enp_seats.std()),
        }


# Party presets moved to electoral_sim.config


# =============================================================================
# QUICK TEST
# =============================================================================

if __name__ == "__main__":
    print("=" * 50)
    print("ElectoralSim Quick Test")
    print("=" * 50)
    
    # Create model
    print("\nCreating model with 100K voters, 10 constituencies...")
    model = ElectionModel(
        n_voters=100_000,
        n_constituencies=10,
        electoral_system="FPTP",
        seed=42,
    )
    
    print(f"Voters: {len(model.voters)}")
    print(f"Parties: {len(model.parties)}")
    
    # Run election
    print("\nRunning FPTP election...")
    results = model.run_election()
    
    print(f"\nResults:")
    print(f"  Turnout: {results['turnout']:.1%}")
    print(f"  Gallagher Index: {results['gallagher']:.2f}")
    print(f"  ENP (votes): {results['enp_votes']:.2f}")
    print(f"  ENP (seats): {results['enp_seats']:.2f}")
    
    party_names = model.parties.df["name"].to_list()
    print(f"\n  Party Results:")
    for i, name in enumerate(party_names):
        votes = results['vote_counts'][i]
        seats = results['seats'][i]
        print(f"    {name}: {votes:,} votes, {seats} seats")
    
    # Test PR
    print("\n" + "-" * 50)
    print("Testing PR (D'Hondt)...")
    
    model_pr = ElectionModel(
        n_voters=100_000,
        n_constituencies=10,
        electoral_system="PR",
        allocation_method="dhondt",
        seed=42,
    )
    
    results_pr = model_pr.run_election()
    print(f"  Gallagher Index: {results_pr['gallagher']:.2f}")
    
    print("\n" + "=" * 50)
    print("All tests passed!")
    print("=" * 50)
