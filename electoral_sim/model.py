"""
ElectionModel - Main simulation model using mesa-frames
Implements India-scale electoral simulation with constituency-based structure

Based on mesa-frames patterns from the official tutorials.
"""

from __future__ import annotations

import numpy as np
import polars as pl
from mesa_frames import AgentSet, Model, DataCollector

from electoral_sim.systems.allocation import dhondt_allocation, sainte_lague_allocation
from electoral_sim.metrics.indices import gallagher_index, effective_number_of_parties
from electoral_sim.numba_accel import (
    vote_mnl_fast, 
    fptp_count_fast,
    compute_utilities_numba,
    NUMBA_AVAILABLE,
)


# =============================================================================
# VOTER AGENTS
# =============================================================================

class VoterAgents(AgentSet):
    """
    Voter agents stored as Polars DataFrame for vectorized operations.
    
    Columns:
        - unique_id: Agent identifier (auto-generated by mesa-frames)
        - constituency: Constituency index (0 to n_constituencies-1)
        - ideology_x: Economic left-right (-1 to 1)
        - ideology_y: Social liberal-conservative (-1 to 1)
        - party_id: Current party identification
        - turnout_prob: Base probability of voting (0-1)
    """
    
    def __init__(self, model: Model, agent_frame: pl.DataFrame):
        """Initialize VoterAgents with a pre-built DataFrame."""
        super().__init__(model)
        self.add(agent_frame.clone())
    
    def step(self) -> None:
        """Called each simulation step for opinion dynamics."""
        # Placeholder for opinion dynamics
        pass


class PartyAgents(AgentSet):
    """
    Party agents stored as Polars DataFrame.
    
    Columns:
        - unique_id: Party identifier
        - name: Party name
        - position_x: Economic left-right (-1 to 1)
        - position_y: Social liberal-conservative (-1 to 1)  
        - valence: Non-policy appeal (0-100)
        - seats: Current seat count
        - vote_share: Last election vote share
    """
    
    def __init__(self, model: Model, agent_frame: pl.DataFrame):
        """Initialize PartyAgents with a pre-built DataFrame."""
        super().__init__(model)
        self.add(agent_frame.clone())
    
    def get_positions(self) -> np.ndarray:
        """Return party positions as (n_parties, 2) array."""
        return np.column_stack([
            self.df["position_x"].to_numpy(),
            self.df["position_y"].to_numpy()
        ])
    
    def step(self) -> None:
        """Called each step for party adaptation."""
        pass


# =============================================================================
# ELECTION MODEL
# =============================================================================

class ElectionModel(Model):
    """
    Main election simulation model using mesa-frames.
    
    Supports:
        - Multiple constituencies (default: 543 for Lok Sabha)
        - Configurable electoral systems (FPTP, PR with D'Hondt/Sainte-Laguë)
        - Multinomial logit voting model
        - Opinion dynamics (placeholder)
    
    Examples:
        # Simple usage
        model = ElectionModel(n_voters=100_000)
        results = model.run_election()
        
        # Using Config
        from electoral_sim import Config
        config = Config(n_voters=100_000, electoral_system="PR")
        model = ElectionModel.from_config(config)
        
        # Using presets
        model = ElectionModel.from_preset("india")
        
        # Chainable API
        results = (
            ElectionModel(n_voters=100_000)
            .with_system("PR")
            .run_election()
        )
    
    Parameters
    ----------
    n_voters : int
        Total number of voter agents
    n_constituencies : int
        Number of electoral constituencies
    parties : list[dict]
        Party configurations with name, position_x, position_y, valence
    electoral_system : str
        'FPTP' or 'PR'
    allocation_method : str
        'dhondt' or 'sainte_lague' (for PR)
    threshold : float
        Electoral threshold for PR (0-1)
    temperature : float
        MNL temperature parameter (lower = more deterministic)
    seed : int | None
        Random seed for reproducibility
    """
    
    def __init__(
        self,
        n_voters: int = 100_000,
        n_constituencies: int = 10,
        parties: list[dict] | None = None,
        electoral_system: str = "FPTP",
        allocation_method: str = "dhondt",
        threshold: float = 0.0,
        temperature: float = 0.5,
        seed: int | None = None,
    ):
        super().__init__(seed)
        
        # Store configuration
        self.n_constituencies = n_constituencies
        self.electoral_system = electoral_system
        self.allocation_method = allocation_method
        self.threshold = threshold
        self.temperature = temperature

        
        # Default parties if not provided
        if parties is None:
            parties = [
                {"name": "Party A", "position_x": -0.3, "position_y": 0.1, "valence": 50},
                {"name": "Party B", "position_x": 0.3, "position_y": -0.1, "valence": 50},
                {"name": "Party C", "position_x": 0.0, "position_y": 0.3, "valence": 45},
            ]
        
        self.n_parties = len(parties)
        
        # Create agent DataFrames using model's random generator
        voter_frame = self._generate_voter_frame(n_voters)
        party_frame = self._generate_party_frame(parties)
        
        # Create agent sets
        self.voters = VoterAgents(self, voter_frame)
        self.parties = PartyAgents(self, party_frame)
        
        # Register agent sets with model
        self.sets += self.voters
        self.sets += self.parties
        
        # Results storage
        self.election_results: list[dict] = []
        
        # Set up data collector
        self.datacollector = DataCollector(
            model=self,
            model_reporters={
                "n_voters": lambda m: len(m.voters),
                "mean_turnout": lambda m: float(m.voters.df["turnout_prob"].mean()),
            },
        )
        self.datacollector.collect()
    
    # =========================================================================
    # CLASS METHODS (Factory methods)
    # =========================================================================
    
    @classmethod
    def from_config(cls, config: "Config") -> "ElectionModel":
        """
        Create model from a Config object.
        
        Args:
            config: Config instance with all parameters
            
        Returns:
            ElectionModel instance
        
        Example:
            config = Config(n_voters=100_000, electoral_system="PR")
            model = ElectionModel.from_config(config)
        """
        from electoral_sim.config import Config
        
        return cls(
            n_voters=config.n_voters,
            n_constituencies=config.n_constituencies,
            parties=config.get_party_dicts(),
            electoral_system=config.electoral_system,
            allocation_method=config.allocation_method,
            threshold=config.threshold,
            temperature=config.temperature,
            seed=config.seed,
        )
    
    @classmethod
    def from_preset(cls, preset: str, **kwargs) -> "ElectionModel":
        """
        Create model from a country preset.
        
        Args:
            preset: One of 'india', 'usa', 'uk', 'germany'
            **kwargs: Override any preset parameters
            
        Returns:
            ElectionModel instance
        
        Example:
            model = ElectionModel.from_preset("india", n_voters=500_000)
        """
        from electoral_sim.config import PRESETS
        
        if preset.lower() not in PRESETS:
            available = list(PRESETS.keys())
            raise ValueError(f"Unknown preset: {preset}. Available: {available}")
        
        config = PRESETS[preset.lower()](**kwargs)
        return cls.from_config(config)
    
    # =========================================================================
    # CHAINABLE API
    # =========================================================================
    
    def with_system(self, system: str) -> "ElectionModel":
        """
        Set electoral system. Chainable.
        
        Args:
            system: 'FPTP' or 'PR'
            
        Returns:
            self for chaining
        """
        self.electoral_system = system
        return self
    
    def with_allocation(self, method: str) -> "ElectionModel":
        """
        Set PR allocation method. Chainable.
        
        Args:
            method: 'dhondt', 'sainte_lague', 'hare', or 'droop'
            
        Returns:
            self for chaining
        """
        self.allocation_method = method
        return self
    
    def with_threshold(self, threshold: float) -> "ElectionModel":
        """
        Set electoral threshold. Chainable.
        
        Args:
            threshold: 0-1 (e.g., 0.05 for 5%)
            
        Returns:
            self for chaining
        """
        self.threshold = threshold
        return self
    
    def with_temperature(self, temperature: float) -> "ElectionModel":
        """
        Set MNL temperature. Chainable.
        
        Args:
            temperature: Lower = more deterministic voting
            
        Returns:
            self for chaining
        """
        self.temperature = temperature
        return self
    
    def _generate_voter_frame(self, n_voters: int) -> pl.DataFrame:
        """
        Generate initial voter DataFrame with full demographics.
        
        Includes:
            - Demographics: age, gender, education, income, religion
            - Party ID: 7-point scale (-3 to +3)
            - Ideology: 2D position
            - Turnout probability
        """
        rng = self.random
        
        # Demographics
        age = rng.integers(18, 90, size=n_voters)  # Voting age population
        gender = rng.choice([0, 1], size=n_voters)  # 0=Male, 1=Female
        
        # Education: 0=None, 1=Primary, 2=Secondary, 3=Graduate, 4=Post-grad
        education = rng.choice([0, 1, 2, 3, 4], size=n_voters, p=[0.15, 0.25, 0.30, 0.20, 0.10])
        
        # Income percentile (0-100)
        income = np.clip(rng.lognormal(3.5, 0.8, n_voters), 0, 100)
        
        # Religion: simplified categories (0-5)
        religion = rng.choice([0, 1, 2, 3, 4, 5], size=n_voters, p=[0.65, 0.14, 0.10, 0.05, 0.03, 0.03])
        
        # 7-point Party ID scale: -3=Strong Left, 0=Independent, +3=Strong Right
        # Normally distributed, clipped to range
        party_id_7pt = np.clip(np.round(rng.normal(0, 1.2, n_voters)), -3, 3).astype(int)
        
        # Ideology influenced by demographics
        # Age: older slightly more conservative
        # Education: higher ed slightly more liberal on social issues
        # Income: higher income slightly more conservative on economic
        base_ideology_x = rng.normal(0, 0.3, n_voters)
        base_ideology_y = rng.normal(0, 0.3, n_voters)
        
        ideology_x = np.clip(
            base_ideology_x + 0.005 * (income - 50) + 0.003 * (age - 50),
            -1, 1
        )
        ideology_y = np.clip(
            base_ideology_y - 0.02 * (education - 2) + 0.005 * (age - 50),
            -1, 1
        )
        
        # Turnout influenced by education and age
        base_turnout = rng.beta(5, 2, n_voters)
        turnout_prob = np.clip(
            base_turnout + 0.02 * education + 0.002 * np.minimum(age - 18, 50),
            0.1, 0.95
        )
        
        return pl.DataFrame({
            # Demographics
            "constituency": rng.integers(0, self.n_constituencies, size=n_voters),
            "age": age,
            "gender": gender,
            "education": education,
            "income": income.astype(np.float64),
            "religion": religion,
            # Political identity
            "party_id_7pt": party_id_7pt,  # -3 to +3 scale
            "ideology_x": ideology_x,
            "ideology_y": ideology_y,
            # Behavior
            "turnout_prob": turnout_prob,
        })
    
    def _generate_party_frame(self, parties: list[dict]) -> pl.DataFrame:
        """Generate party DataFrame from configuration."""
        n = len(parties)
        return pl.DataFrame({
            "name": [p["name"] for p in parties],
            "position_x": [float(p.get("position_x", 0.0)) for p in parties],
            "position_y": [float(p.get("position_y", 0.0)) for p in parties],
            "valence": [float(p.get("valence", 50.0)) for p in parties],
            "seats": np.zeros(n, dtype=np.int64),
            "vote_share": np.zeros(n, dtype=np.float64),
        })
    
    def _compute_utilities(self) -> np.ndarray:
        """
        Compute utility matrix (n_voters x n_parties) using proximity model.
        
        Uses Numba parallel acceleration when available.
        Utility = -distance + valence_weight * valence
        """
        # Get voter positions
        voter_x = self.voters.df["ideology_x"].to_numpy()
        voter_y = self.voters.df["ideology_y"].to_numpy()
        
        # Get party positions and valence
        party_positions = self.parties.get_positions()
        party_x = party_positions[:, 0]
        party_y = party_positions[:, 1]
        valence = self.parties.df["valence"].to_numpy()
        
        if NUMBA_AVAILABLE:
            return compute_utilities_numba(voter_x, voter_y, party_x, party_y, valence)
        else:
            # Fallback to vectorized NumPy
            dist_x = voter_x[:, np.newaxis] - party_x[np.newaxis, :]
            dist_y = voter_y[:, np.newaxis] - party_y[np.newaxis, :]
            distances = np.sqrt(dist_x**2 + dist_y**2)
            return -distances + 0.01 * valence[np.newaxis, :]
    
    def _vote_mnl(self, utilities: np.ndarray) -> np.ndarray:
        """
        Multinomial logit voting: P(j) = exp(U_j/τ) / Σexp(U_k/τ)
        
        Uses Numba acceleration when available (~10x faster).
        
        Returns array of vote choices (party indices).
        """
        return vote_mnl_fast(utilities, self.temperature, self.random)
    
    def _decide_turnout(self) -> np.ndarray:
        """Determine which voters turn out based on turnout probability."""
        turnout_probs = self.voters.df["turnout_prob"].to_numpy()
        random_vals = self.random.random(len(turnout_probs))
        return random_vals < turnout_probs
    
    def run_election(self) -> dict:
        """
        Run a single election and return results.
        
        Returns:
            Dictionary with vote counts, seats, turnout, and metrics
        """
        # Compute utilities and cast votes
        utilities = self._compute_utilities()
        votes = self._vote_mnl(utilities)
        
        # Determine turnout
        will_vote = self._decide_turnout()
        
        # Filter to voters who turned out
        constituencies = self.voters.df["constituency"].to_numpy()
        voted_constituencies = constituencies[will_vote]
        voted_choices = votes[will_vote]
        
        # Count votes
        if self.electoral_system == "FPTP":
            results = self._count_fptp(voted_constituencies, voted_choices)
        else:
            results = self._count_pr(voted_choices)
        
        # Calculate metrics
        vote_shares = results["vote_counts"] / results["vote_counts"].sum()
        seat_shares = results["seats"] / results["seats"].sum() if results["seats"].sum() > 0 else vote_shares
        
        results["gallagher"] = gallagher_index(vote_shares, seat_shares)
        results["enp_votes"] = effective_number_of_parties(vote_shares)
        results["enp_seats"] = effective_number_of_parties(seat_shares)
        results["turnout"] = will_vote.sum() / len(will_vote)
        
        # Update party DataFrame with results
        self.parties.df = self.parties.df.with_columns([
            pl.Series("seats", results["seats"]),
            pl.Series("vote_share", vote_shares),
        ])
        
        self.election_results.append(results)
        return results
    
    def _count_fptp(self, constituencies: np.ndarray, votes: np.ndarray) -> dict:
        """
        First Past The Post: winner takes all in each constituency.
        
        Uses Numba parallel acceleration when available.
        """
        seats, vote_counts = fptp_count_fast(
            constituencies, votes, self.n_constituencies, self.n_parties
        )
        
        return {
            "system": "FPTP",
            "seats": seats,
            "vote_counts": vote_counts,
            "n_constituencies": self.n_constituencies,
        }
    
    def _count_pr(self, votes: np.ndarray) -> dict:
        """Proportional Representation with seat allocation."""
        # Vectorized vote counting
        vote_counts = np.bincount(votes, minlength=self.n_parties).astype(np.int64)
        
        # Allocate seats using registry for all methods
        from electoral_sim.systems.allocation import allocate_seats
        seats = allocate_seats(vote_counts, self.n_constituencies, self.allocation_method, self.threshold)
        
        return {
            "system": "PR",
            "method": self.allocation_method,
            "seats": seats,
            "vote_counts": vote_counts,
            "n_constituencies": self.n_constituencies,
        }
    
    def step(self) -> None:
        """Run one simulation step (for opinion dynamics)."""
        self.sets.do("step")
        self.datacollector.collect()
    
    def run(self, n_steps: int = 100, election_interval: int = 10) -> None:
        """
        Run simulation for n_steps, holding elections at intervals.
        
        Args:
            n_steps: Total simulation steps
            election_interval: Steps between elections
        """
        for step in range(n_steps):
            self.step()
            
            if (step + 1) % election_interval == 0:
                self.run_election()
    
    def get_results(self) -> list[dict]:
        """Return all election results."""
        return self.election_results


# Party presets moved to electoral_sim.config


# =============================================================================
# QUICK TEST
# =============================================================================

if __name__ == "__main__":
    print("=" * 50)
    print("ElectoralSim Quick Test")
    print("=" * 50)
    
    # Create model
    print("\nCreating model with 100K voters, 10 constituencies...")
    model = ElectionModel(
        n_voters=100_000,
        n_constituencies=10,
        electoral_system="FPTP",
        seed=42,
    )
    
    print(f"Voters: {len(model.voters)}")
    print(f"Parties: {len(model.parties)}")
    
    # Run election
    print("\nRunning FPTP election...")
    results = model.run_election()
    
    print(f"\nResults:")
    print(f"  Turnout: {results['turnout']:.1%}")
    print(f"  Gallagher Index: {results['gallagher']:.2f}")
    print(f"  ENP (votes): {results['enp_votes']:.2f}")
    print(f"  ENP (seats): {results['enp_seats']:.2f}")
    
    party_names = model.parties.df["name"].to_list()
    print(f"\n  Party Results:")
    for i, name in enumerate(party_names):
        votes = results['vote_counts'][i]
        seats = results['seats'][i]
        print(f"    {name}: {votes:,} votes, {seats} seats")
    
    # Test PR
    print("\n" + "-" * 50)
    print("Testing PR (D'Hondt)...")
    
    model_pr = ElectionModel(
        n_voters=100_000,
        n_constituencies=10,
        electoral_system="PR",
        allocation_method="dhondt",
        seed=42,
    )
    
    results_pr = model_pr.run_election()
    print(f"  Gallagher Index: {results_pr['gallagher']:.2f}")
    
    print("\n" + "=" * 50)
    print("All tests passed!")
    print("=" * 50)
